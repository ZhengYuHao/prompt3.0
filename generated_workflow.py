"""
Auto-generated by WaAct Compiler
DO NOT EDIT THIS FILE MANUALLY
"""

from typing import Dict, Any
from llm_client import invoke_function  # 需要实现 LLM 客户端


def step_1_compute_tech_stack():
    """Auto-generated module"""
    return duration_days, duration_days_2, duration_days_3, tech_stack


async def step_2_vector_search(duration_days_2, query, query_type):
    """Auto-generated module"""
    if query_type == "simple_fact":
        results = await invoke_function('vector_search', query=query)
        if results.similarity > 0.85:
            results.top_n = 3
        elif results.similarity <= 0.85:
            results = await invoke_function('rerank_model', results=results)
            results.top_n = 5
        else:
            results = await invoke_function('hybrid_search', query=query)
        return results
    elif query_type == "complex_reasoning":
        intent = await invoke_function('intent_decomposition', query=query)
        results = await invoke_function('graph_search', intent=intent)
        if results.matched_nodes   is  not   None:
            results.cache_ttl = duration_days_2 * 60  # 30分钟
            await invoke_function('cache_store', results=results)
        elif results.matched_nodes  is  None:
            results = await invoke_function('full_search', query=query)
        return results
    elif query_type == "code_analysis":
        if code_lines > 500:
            analysis = await invoke_function('static_analysis', query=query)
        elif code_lines <= 500:
            analysis = await invoke_function('semantic_analysis', query=query)
            doc = await invoke_function('generate_explanation', analysis=analysis)
        return doc
    else:
        results = await invoke_function('default_search', query=query)
        return results


async def step_3_strong_model(query, user_feedback):
    """Auto-generated module"""
    if user_feedback == "regenerate":
        results = await invoke_function('strong_model', query=query)
        return results
    elif user_feedback.count("unsatisfied") >= 3:
        await invoke_function('escalate_to_human', query=query)


async def step_4_verify_identity(query, user):
    """Auto-generated module"""
    if "金融" in query:
        verification = await invoke_function('verify_identity', user=user)
        if verification == False:
            await invoke_function('reject_service')
            await invoke_function('log', query=query)
            return None


async def step_5_queue_request(request_count):
    """Auto-generated module"""
    if request_count > 50:
        await invoke_function('queue_request')
    else:
        await invoke_function('process_request')
    return None


def step_6_compute_retention(duration_days, duration_days_2, duration_days_3, log_type):
    """Auto-generated module"""
    if log_type == "error":
        retention = duration_days  # 90天
    elif log_type == "access":
        retention = duration_days_2  # 30天
    elif log_type == "debug":
        retention = duration_days_3  # 7天
    return retention


def step_7_upload_log(retention):
    """Auto-generated module"""
    await invoke_function('upload_log', log=log, retention_days=retention)
    return log


async def step_8_trigger_alert(p95_latency, qps):
    """Auto-generated module"""
    if qps < 10:
        await invoke_function('trigger_alert')
    elif p95_latency > 3:
        await invoke_function('scale_out')
    return None


async def main_workflow(input_params: dict):
    """
    主工作流 - 自动生成
    
    Args:
        input_params: 包含 ['log_type', 'p95_latency', 'qps', 'query', 'query_type', 'request_count', 'user', 'user_feedback'] 的字典
    
    Returns:
        执行结果上下文
    """
    # 初始化上下文
    ctx = input_params.copy()

    # Module 1: step_1_compute_tech_stack
    ctx["duration_days"], ctx["duration_days_2"], ctx["duration_days_3"], ctx["tech_stack"] = step_1_compute_tech_stack()

    # Module 2: step_2_vector_search
    ctx["__doc__"], ctx["__results__"], ctx["analysis"], ctx["code_lines"], ctx["doc"], ctx["intent"], ctx["results"] = await step_2_vector_search(ctx.get("duration_days_2"), ctx.get("query"), ctx.get("query_type"))

    # Module 3: step_3_strong_model
    ctx["__results__"], ctx["results"] = await step_3_strong_model(ctx.get("query"), ctx.get("user_feedback"))

    # Module 4: step_4_verify_identity
    ctx["None"], ctx["verification"] = await step_4_verify_identity(ctx.get("query"), ctx.get("user"))

    # Module 5: step_5_queue_request
    await step_5_queue_request(ctx.get("request_count"))

    # Module 6: step_6_compute_retention
    ctx["retention"] = step_6_compute_retention(ctx.get("duration_days"), ctx.get("duration_days_2"), ctx.get("duration_days_3"), ctx.get("log_type"))

    # Module 7: step_7_upload_log
    ctx["log"] = step_7_upload_log(ctx.get("retention"))

    # Module 8: step_8_trigger_alert
    await step_8_trigger_alert(ctx.get("p95_latency"), ctx.get("qps"))

    return ctx



if __name__ == "__main__":
    import asyncio
    
    # 测试输入
    test_input = {
        # TODO: 填充实际参数
    }
    
    result = asyncio.run(main_workflow(test_input))
    from logger import info
    info("执行结果:", result)